/// [問題 18] 最大となる合計のパス1
///
/// 以下の三角形の頂点から開始して、下の行の隣接する数へ移動したとき、頂点から下までの合計の最大値は23である。
///
///         3
///        7 4
///       2 4 6
///      8 5 9 3
///
/// それは、3 + 7 + 4 + 9 = 23
///
///     3
///     7 4
///     2 4 6
///     8 5 9 3
///
/// 下の三角形の頂点から下までの合計の最大値を見つけなさい。
///
/// 注意: たった16384ルートしかないので、すべてのルートを試して解答することは可能である。
/// しかしながら、問題67は、100行含む三角形で同じ調整をする。
/// ブルート・フォース（総当り）によって解くことはできず、賢い方法が求められる。
///
/// [考え方]
/// 三角形の頂点の位置を(0, 0)と表現する。
/// また、三角形の最終行の最終列は(14, 14)と表現される。
/// 次の行において、進めるパスは(1, 0)と(1, 1)となる。
/// また、(1, 0)から次の行に進めるパスは(2, 0)と(2, 1)、(1, 1)から進めるパスは(2, 1)と(2, 2)である。
/// さらに、(2, 0)から次の行に進めるパスは(3, 0)と(3, 1)、(2, 1)からは(3, 1)と(3, 2)、(2, 2)からは(3, 2)と(3, 3)である。
/// よって、(i, j)から進めるパスは、(i + 1, j)と(i + 1, j + 1)と一般化できる。
///
/// 最も下の行の１つ上の行から始めて、下の行に進めるパスの内大きい方の数と自分自身の数を足した値を、自分自身の位置に記録する。
/// value(i, j) = value(i, j) + max(value(i + 1, j), value(i + 1, j + 1))
/// これを三角形の頂点まで上の行に移動して、最大の合計値を求める。
use std::{cmp, time::Instant};

use project_euler::measure;

fn problem() {
    let tri = vec![
        "75",
        "95 64",
        "17 47 82",
        "18 35 87 10",
        "20 04 82 47 65",
        "19 01 23 75 03 34",
        "88 02 77 73 07 63 67",
        "99 65 04 28 06 16 70 92",
        "41 41 26 56 83 40 80 70 33",
        "41 48 72 33 47 32 37 16 94 29",
        "53 71 44 65 25 43 91 52 97 51 14",
        "70 11 33 28 77 73 17 78 39 68 17 57",
        "91 71 52 38 17 14 91 43 58 50 27 29 48",
        "63 66 04 68 89 53 67 30 73 16 69 87 40 31",
        "04 62 98 27 23 09 70 98 73 93 38 53 60 04 23",
    ];
    let mut tri: Vec<Vec<i32>> = tri
        .iter()
        .map(|&row| {
            row.split(' ')
                .into_iter()
                .map(|v| v.parse::<i32>().unwrap())
                .collect()
        })
        .collect();

    for row in (0..=13).rev() {
        for col in 0..=row {
            tri[row][col] += cmp::max(tri[row + 1][col], tri[row + 1][col + 1])
        }
    }
    println!("{}", tri[0][0]);
}

fn main() {
    measure!(problem());
}
