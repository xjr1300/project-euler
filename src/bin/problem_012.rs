/// [問題 12] Highly divisible triangular number
///
/// 三角数の列は自然数を足すことで生成される。
/// 7番目の三角数は、1 + 2 + 3 + 4 + 5 + 6 + 7 = 28である。
/// 最初の10個までの三角数は以下の通り。
///     1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
/// 最初の7つの三角数の約数は、以下の通り。
///  1: 1
///  3: 1,3
///  6: 1,2,3,6
/// 10: 1,2,5,10
/// 15: 1,3,5,15
/// 21: 1,3,7,21
/// 28: 1,2,4,7,14,28
/// これから、7番目の三角数である28は、5個より多く約数をもつ最初の三角数であることが分かる.
/// 500個より多く約数をもつ最初の三角数を求めなさい。
///
/// [考え方]
/// 三角数は、階差1の等差数列の和であるため、n番目の三角数は以下で求められる。
///     n * (n + 1) / 2
///
/// 隣り合う正の自然数nとn+1は、共通する約数が1しかない（互いに素である）。
///     [証明1]
///     隣り合う自然数をnとn+1として、これらに共通な約数mがあるとすると、以下の通り表現できる。
///         n = ma
///         n + 1 = mb
///     上記から両辺を減算すると、以下の通りである。
///         -1 = ma - mb
///         m(a - b) = -1
///         m(b - a) = 1
///     よって、m = 1かつb-a=1となり、共通する約数は1であり、隣り合う自然数nとn+1は、互いに素である。
///     [証明2]
///     隣り合う自然数nとn+1が互いに素でないと仮定すると、2以上の約数dが存在する。
///     dの倍数どおしの差もdの倍数(da - db = d(a - b))であるため、(n+1)-nもdの倍数となるが、
///     実際には(n+1)-n=1であるため矛盾する。
///     よって、隣り合う自然数nとn+1は、互いに素である。
///
/// ここで、nが偶数の場合はn/2とn+1が、nが奇数の場合はnと(n+1)/2が互いに素である。
///     互いに素である自然数同士において、一方を一方の約数で割っても、もともと1以外に共通な約数はないことから、互いに素のままである。
///
/// [約数の数]
/// 例えば、12の約数は必ず12の素因数のどれかのみを含み、12の素因数以外は含まれない。
/// よって、12の約数は12を素因数分解したとき、各素因数をかける個数の場合の数（乗数+1だけの場合の数）が約数になる。
///     12の素因数分解: 2^2 * 3^1
///     [約数]
///     2^0 * 3^0 = 1
///     2^1 * 3^0 = 2
///     2^0 * 3^1 = 3
///     2^2 * 3^0 = 4
///     2^1 * 3^1 = 6
///     2^2 * 3^1 = 12
/// 2をかける個数の場合の数は3通り、3をかける個数の場合の数は2通り、よって各素因数をかける個数の場合の数は6通り。
/// よって、12の約数の数は6通り。
/// 一般的に、ある自然数nの約数の数は、nを素因数分解したときの、各素因数の乗数に1を足した結果の積になる。
///     (2 + 1) * (1 + 1) = 6
///
/// 正の自然数xの約数をf(x)とすると、aとbが互いに素であれば、f(ab)=f(a)*f(b)
///     2の約数の数は2、3の約数の数は2 -> 6の約数の数は4(1, 2, 3, 6)
///     2の約数の数は2、5の約数の数は2 -> 10の約数の数は6(1, 2, 5, 10)
///     a1^xa * a2^ya * a3^za の約数の個数は(xa+1)*(ya+1)*(za+1)
///     b1^xb * b2^yb の約数の個数は(xb+1)*(yb+1)
///     その積は、a1^xa * a2^ya * a3^za * b1^xb * b2^ybであるため、約数の個数は(xa+1)*(ya+1)*(za+1)*(xb+1)*(yb+1)
///     なお、anとbnは互いに素である。
///
/// n番目の三角数の数をTnとすると、
///     nが偶数の場合、Tnの約数の数はf(Tn) = f(n/2)*f(n+1)であり、
///     nが奇数の場合、Tnの約数の数はf(Tn) = f(n)*f((n+1)/2)である。
/// この関係を小さい三角数から見ていくと、
///     f(T1) = f(1)*f(2/2)
///     f(T2) = f(2/2)*f(3)
///     f(T3) = f(3)*f(4/2)
///     f(T4) = f(4/2)*f(5)
///     f(T5) = f(5)*f(6/2)
///     ...となり、前の式の1部が次の式に現れる。
///     よって、小さい方から三角数の約数の個数を記憶しておけば、次の三角数の約数を計算するときに利用でき、計算量を節約できる。
///
/// また、三角数を隣り合う2つの自然数(n*(n+1))の積で表現できる場合、現在までに計算した約数を利用でき、計算量を節約できる。
use std::collections::HashMap;
use std::time::Instant;

use project_euler::measure;

fn triangle_number(term: u64) -> u64 {
    term * (term + 1) / 2
}

fn count_factors(tri: u64, factors: &mut HashMap<u64, u64>) -> u64 {
    // 三角数の約数の個数を計算済みの場合は、計算した約数の数を返却
    if factors.contains_key(&tri) {
        return *factors.get(&tri).unwrap();
    }

    // 三角数を隣接する2つの自然数で表現できるか確認
    let q = f64::sqrt(tri as f64).trunc() as u64;
    let count = if q * (q + 1) == tri {
        // 三角数を隣接する2つの自然数で表現できる場合、その2つの数は互いに素であるため、
        // それぞれの約数の個数を計算して、その積を三角数の約数の個数とする。
        count_factors(q, factors) * count_factors(q + 1, factors)
    } else {
        // 三角数の約数の数を計算する。
        // 約数が見つかった場合、三角数を約数で割った数も約数である。
        // よって、三角数の平方根を計算して、平方根よりも小さい最大の自然数までの約数の個数を計算して、後で2倍する。
        // なお、三角数の平方根が自然数になる場合もあるため、その場合は後で約数の個数に1を加える。
        let mut count = 0;
        for m in 1..q {
            if tri % m == 0 {
                count += 1;
            }
        }
        count *= 2;
        if q * q == tri {
            count += 1;
        }
        count
    };
    factors.insert(tri, count);

    count
}

fn problem_012() {
    // 自然数キーにその自然数の約数を格納するハッシュマップ
    let mut factors: HashMap<u64, u64> = HashMap::new();
    factors.insert(1, 1); // 1の約数の数を登録
    factors.insert(2, 2); // 2の約数の数を登録

    // 三角数の約数を2個目から計算
    for term in 2.. {
        let tri = triangle_number(term);
        let count = count_factors(tri, &mut factors);
        if 500 <= count {
            println!("{}", tri);
            break;
        }
    }
}

fn main() {
    measure!({
        problem_012();
    });
}

#[cfg(test)]
mod tests {
    use super::triangle_number;

    #[test]
    fn test_triangle_numbers() {
        let numbers: Vec<u64> = (1u64..=10).map(|n| triangle_number(n)).collect();
        assert_eq!(numbers, vec![1u64, 3, 6, 10, 15, 21, 28, 36, 45, 55]);
    }
}
