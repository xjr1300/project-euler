/// [問題 20] 階乗の桁の合計
///
/// n! は n × (n − 1) × ... × 3 × 2 × 1 を意味する。
/// 例えば、 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800 で、
/// 10! の桁の合計は、3 + 6 + 2 + 8 + 8 + 0 + 0 = 27 である。
/// 100! の桁の合計を求めなさい。
///
/// [考え方]
/// 数を桁の逆順で1桁ずつベクタに記録する。
/// 各桁の数を現在の値で乗じた値を、一時的にその桁の数として記憶する。
/// このとき、その桁は、2桁以上の数になる場合がある。
/// その後、上位の桁に繰り上がった数値を足していく。
/// このときも、上位の桁は、2桁以上の数になる場合があるが、その桁を処理するときに1桁の数になる。
///
/// 100! = 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000

static RANK: usize = 256;
static FACTORIAL: &str = "93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000";

fn main() {
    let mut digits = vec![0u32; RANK];
    digits[0] = 1;
    for i in 2..=100 {
        // 各桁の数に、現在の値を乗算
        for j in 0..RANK {
            digits[j] *= i;
        }

        // 最上位の桁（ベクタの末尾の要素）が9より大きくなったら桁あふれ
        if 9 < digits[RANK - 1] {
            eprintln!("overflow!!");
        }

        // 繰り上がり処理
        for j in 0..RANK - 1 {
            digits[j + 1] += digits[j] / 10;
            digits[j] %= 10;
        }
    }

    let factorial_digits: Vec<u8> = FACTORIAL
        .chars()
        .map(|c| c.to_digit(10).unwrap() as u8)
        .rev()
        .collect();
    for i in 0..factorial_digits.len() {
        assert_eq!(factorial_digits[i] as u32, digits[i])
    }

    println!("{}", digits.iter().sum::<u32>());
}
